<channel>
  <id>d0b1382b-6d81-47f5-8382-e943e5bb4f9f</id>
  <name>file-utils</name>
  <description>This channel provides file move and copy calls. Making of directories is also catered for.

The process of file modification/creation is audited.</description>
  <enabled>true</enabled>
  <version>2.2.1.5861</version>
  <lastModified>
    <time>1371669682067</time>
    <timezone>Europe/London</timezone>
  </lastModified>
  <revision>62</revision>
  <sourceConnector>
    <name>sourceConnector</name>
    <properties>
      <property name="DataType">Channel Reader</property>
      <property name="responseValue">None</property>
    </properties>
    <transformer>
      <steps>
        <step>
          <sequenceNumber>0</sequenceNumber>
          <script>tmp[&apos;operation&apos;] = validate(msg[&apos;operation&apos;].toString(), &apos;&apos;, new Array());</script>
          <type>Message Builder</type>
          <data class="map">
            <entry>
              <string>Variable</string>
              <string>tmp[&apos;operation&apos;]</string>
            </entry>
            <entry>
              <string>DefaultValue</string>
              <string></string>
            </entry>
            <entry>
              <string>RegularExpressions</string>
              <list/>
            </entry>
            <entry>
              <string>Mapping</string>
              <string>msg[&apos;operation&apos;].toString()</string>
            </entry>
          </data>
        </step>
        <step>
          <sequenceNumber>1</sequenceNumber>
          <script>tmp[&apos;sourceDir&apos;] = validate(msg[&apos;sourceDir&apos;].toString(), &apos;&apos;, new Array());</script>
          <type>Message Builder</type>
          <data class="map">
            <entry>
              <string>Variable</string>
              <string>tmp[&apos;sourceDir&apos;]</string>
            </entry>
            <entry>
              <string>DefaultValue</string>
              <string></string>
            </entry>
            <entry>
              <string>RegularExpressions</string>
              <list/>
            </entry>
            <entry>
              <string>Mapping</string>
              <string>msg[&apos;sourceDir&apos;].toString()</string>
            </entry>
          </data>
        </step>
        <step>
          <sequenceNumber>2</sequenceNumber>
          <script>tmp[&apos;destDir&apos;] = validate(msg[&apos;destDir&apos;].toString(), &apos;&apos;, new Array());</script>
          <type>Message Builder</type>
          <data class="map">
            <entry>
              <string>Variable</string>
              <string>tmp[&apos;destDir&apos;]</string>
            </entry>
            <entry>
              <string>DefaultValue</string>
              <string></string>
            </entry>
            <entry>
              <string>RegularExpressions</string>
              <list/>
            </entry>
            <entry>
              <string>Mapping</string>
              <string>msg[&apos;destDir&apos;].toString()</string>
            </entry>
          </data>
        </step>
        <step>
          <sequenceNumber>3</sequenceNumber>
          <script>tmp[&apos;fileName&apos;] = validate(msg[&apos;fileName&apos;].toString(), &apos;&apos;, new Array());</script>
          <type>Message Builder</type>
          <data class="map">
            <entry>
              <string>Variable</string>
              <string>tmp[&apos;fileName&apos;]</string>
            </entry>
            <entry>
              <string>DefaultValue</string>
              <string></string>
            </entry>
            <entry>
              <string>RegularExpressions</string>
              <list/>
            </entry>
            <entry>
              <string>Mapping</string>
              <string>msg[&apos;fileName&apos;].toString()</string>
            </entry>
          </data>
        </step>
        <step>
          <sequenceNumber>4</sequenceNumber>
          <name></name>
          <script>tmp[&apos;destFileName&apos;] = validate(msg[&apos;destFileName&apos;].toString(), &apos;&apos;, new Array());</script>
          <type>Message Builder</type>
          <data class="map">
            <entry>
              <string>Variable</string>
              <string>tmp[&apos;destFileName&apos;]</string>
            </entry>
            <entry>
              <string>DefaultValue</string>
              <string></string>
            </entry>
            <entry>
              <string>RegularExpressions</string>
              <list/>
            </entry>
            <entry>
              <string>Mapping</string>
              <string>msg[&apos;destFileName&apos;].toString()</string>
            </entry>
          </data>
        </step>
      </steps>
      <inboundTemplate encoding="base64">PGZpbGVPcGVyYXRpb24+Cgk8b3BlcmF0aW9uPjwvb3BlcmF0aW9uPgoJPHNvdXJjZURpcj48L3Nv
dXJjZURpcj4KCTxkZXN0RGlyPjwvZGVzdERpcj4KCTxmaWxlTmFtZT48L2ZpbGVOYW1lPgoJPGRl
c3RGaWxlTmFtZT48L2Rlc3RGaWxlTmFtZT4KPC9maWxlT3BlcmF0aW9uPg==</inboundTemplate>
      <outboundTemplate encoding="base64">PGZpbGVPcGVyYXRpb24+Cgk8b3BlcmF0aW9uPjwvb3BlcmF0aW9uPgoJPHNvdXJjZURpcj48L3Nv
dXJjZURpcj4KCTxkZXN0RGlyPjwvZGVzdERpcj4KCTxmaWxlTmFtZT48L2ZpbGVOYW1lPgoJPGRl
c3RGaWxlTmFtZT48L2Rlc3RGaWxlTmFtZT4KPC9maWxlT3BlcmF0aW9uPg==</outboundTemplate>
      <inboundProtocol>XML</inboundProtocol>
      <outboundProtocol>XML</outboundProtocol>
      <inboundProperties>
        <property name="stripNamespaces">true</property>
      </inboundProperties>
      <outboundProperties>
        <property name="stripNamespaces">true</property>
      </outboundProperties>
    </transformer>
    <filter>
      <rules/>
    </filter>
    <transportName>Channel Reader</transportName>
    <mode>SOURCE</mode>
    <enabled>true</enabled>
    <version>2.2.1.5861</version>
  </sourceConnector>
  <destinationConnectors>
    <connector>
      <name>Destination 1</name>
      <properties>
        <property name="DataType">Channel Writer</property>
        <property name="host">sink</property>
        <property name="synchronised">0</property>
        <property name="template">${message.encodedData}</property>
      </properties>
      <transformer>
        <steps/>
        <inboundProtocol>XML</inboundProtocol>
        <outboundProtocol>XML</outboundProtocol>
        <inboundProperties>
          <property name="stripNamespaces">true</property>
        </inboundProperties>
        <outboundProperties>
          <property name="stripNamespaces">true</property>
        </outboundProperties>
      </transformer>
      <filter>
        <rules/>
      </filter>
      <transportName>Channel Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <version>2.2.1.5861</version>
    </connector>
  </destinationConnectors>
  <properties>
    <property name="clearGlobalChannelMap">true</property>
    <property name="dont_store_filtered">false</property>
    <property name="encryptData">false</property>
    <property name="error_messages_only">false</property>
    <property name="initialState">started</property>
    <property name="max_message_age">-1</property>
    <property name="store_messages">false</property>
    <property name="synchronous">true</property>
    <property name="transactional">false</property>
  </properties>
  <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
  <postprocessingScript>/**
 * Prepare a file for moving, copying or deleting.
 * An error will be reported if the &apos;operation&apos; element
 * is not one of &apos;move&apos;, &apos;copy&apos;, &apos;mkdir&apos; or &apos;delete&apos;.
 * The source directory and file name to copy from that
 * directory MUST exist. The destination directory&apos;
 * if it d_OE_DB_USER_s not exist, is created. If creation fails
 * an error is reported. An error is also reported if
 * the move or copy fails. Success is also reported.
 * In all cases for reporting, the details of the file
 * operation are reported (copy/move, source, destination
 * and filename).
 * 
 * Any move or copy will fail if the destination file
 * exists; it is up to callers to move or delete the
 * destination file and audit the information.
 * 
 * Only source directory and file are required for delete.
 * 
 * Note that copying of directories is not catered for; the
 * copy operation is for files only.
 * 
 */
var data = new XML(message);
var srcDir = data[&apos;sourceDir&apos;];
var destDir = data[&apos;destDir&apos;];
var filename = data[&apos;fileName&apos;];
var destFilename = data[&apos;destFileName&apos;];
var operation = data[&apos;operation&apos;];

// TODO error check - make sure src directory and file name exist

// TODO error check - if src or dest are not directories, throw an error

// TODO error check - if dest + filename exist, throw error
// ... unless - add rules for mode e.g. overwrite, append, error etc.

var fileData = &quot;Operation: &quot;+ operation + &quot;, Source directory: &quot; + srcDir
	+ &quot;, Destination directory: &quot; + destDir
	+ &quot;, Source file name: &quot; + filename
	+ &quot;, Destination file name: &quot; + destFilename;

var destFile = new java.io.File(new java.io.File(destDir), destFilename);
if (destFile.exists() &amp;&amp; destFile.isFile()) {
	log(channelId, null, &quot;error&quot;, &quot;Failure to perform operation &apos;&quot; + operation
			+ &quot;&apos;; file already exists: &apos;&quot; + destFile.getAbsolutePath() + &quot;&apos;&quot;);
	return;
}

if (destDir == null) {
	destDir = &apos;&apos;;
}
if (destFilename == null) {
	destFilename = &apos;&apos;;
}

var src = new java.io.File(new java.io.File(srcDir), filename);
var size = src.length();
var fileId = getFileId(src);
var fileKey = getFileKey(fileId);

if (operation == &apos;move&apos;) {
	var dir = new java.io.File(destDir);
	var f = new java.io.File(dir, destFilename);
	try {
		var moved = src.renameTo(f);
		if (moved == &apos;false&apos;) {
			log(channelId, null, &apos;error&apos;, &quot;Failed to move file: &quot; + fileData)
		} else {
			log(channelId, null, &apos;info&apos;, fileData);
			routeModel(&apos;update&apos;, buildRoutableModel(fileId, &apos;FsFile&apos;, [&apos;deleted&apos;], [&apos;1&apos;]));
			var type = &apos;d&apos;;
			if (!f.isDirectory()) {
				addFileWithKey(f, fileKey);
				type = &apos;f&apos;;
			} else {
				addDirectory(f);
			}
			fileAudit(&apos;m&apos;, type, src.getParentFile(), src, f.getParentFile(), f, size, f.length());
			fileAudit(&apos;d&apos;, type, src.getParentFile(), src, null, null, size, null);
		}
	} catch(err) {
		log(channelId, null, &apos;error&apos;, &quot;Error moving file: &quot; + err + &quot; (&quot; + fileData + &quot;)&quot;);		
	}
} else if (operation == &apos;copy&apos;) {
	try {
		var dest = new java.io.File(destDir);
		// TODO AUDIT THIS! CLEAN IT UP!
		dest.mkdirs();
	
		var inp = new java.io.FileReader(src);
		var outp = new java.io.FileWriter(new java.io.File(dest, destFilename) );

		var c=0;
	
		while ((c = inp.read()) != -1) {
			outp.write(c);
		}

		inp.close();
		outp.close();
		log(channelId, null, &apos;info&apos;, fileData);
		addFileWithKey(new java.io.File(dest, destFileName), fileKey);
	    fileAudit(&apos;c&apos;, &apos;f&apos;, src.getParentFile(), src, dest.getParentFile(), dest, src.length(), dest.length());
		
	} catch (err) {
		log(channelId, null, &apos;error&apos;, &quot;Error copying file: &quot; + err + &quot; (&quot; + fileData + &quot;)&quot;);
	}
} else if (operation == &apos;mkdir&apos;) {
	try {
		var src = new java.io.File(srcDir);
		// TODO AUDIT THIS! CLEAN IT UP!
		mkdirs(src);
		log(channelId, null, &apos;info&apos;, &quot;Success: &quot; + fileData);
	} catch (err) {
		log(channelId, null, &apos;error&apos;, &quot;Error calling mkdir: &quot; + err + &quot; (&quot; + fileData + &quot;)&quot;);
	}
} else if (operation == &apos;delete&apos;) {
	try {
		var src = new java.io.File(srcDir);
		// TODO AUDIT THIS! CLEAN IT UP!
		FileUtil.deleteFile(new java.io.File(srcDir + &apos;/&apos; + filename));
		log(channelId, null, &apos;info&apos;, &quot;Deleted: &quot; + fileData);
	} catch (err) {
		log(channelId, null, &apos;error&apos;, &quot;Error deleting file: &quot; + err + &quot; (&quot; + fileData + &quot;)&quot;);
	}
} else {
	log(channelId, null, &apos;error&apos;, &apos;No such file operation: \&apos;&apos; + operation + &apos;\&apos;&apos;);
}
return;

/**
 * Recursively create all necessary directories.
 * 
 * The process is logged and audited for each create.
 * 
 * java.io.File dirs - a file path reference to a directory path,
 * some or all of which may exist. The function traverses the tree
 * until it finds a parent directory that exists, then creates
 * all children in the right order.
 */
function mkdirs(dirs) {
	if (!dirs.exists()) {
		var parent = dirs.getParentFile();
		mkdirs(parent);
		try {
			dirs.mkdir();		
			log(channelId, null, &apos;info&apos;, &quot;Directory &apos;&quot; + dirs.getAbsolutePath()
				+ &quot;&apos; wasn&apos;t present; created successfully&quot;);
			addDirectory(dirs);
	    	fileAudit(&apos;i&apos;, &apos;d&apos;, dirs.getParentFile(), dirs, null, null, dirs.length(), null);
		} catch(err) {
			log(channelId, null, &apos;error&apos;, &quot;Error making directory: &quot; + err + &quot; (&quot; + dirs.getAbsolutePath() + &quot;)&quot;);		
		}
	}
}</postprocessingScript>
  <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
  <shutdownScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</shutdownScript>
</channel>