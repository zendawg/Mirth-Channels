<list>
  <codeTemplate>
    <id>c06d901d-75c7-4ae4-acb7-7f64e7964662</id>
    <name>routeModel</name>
    <tooltip></tooltip>
    <code>/**
 * 
 * 
 * 
 * 
 * 
 * 
 */
function routeModel(operation, json) {
	var channelName = null;
	if (operation == &apos;view&apos;) {
		channelName = &apos;rest-api-model-reader&apos;;
	} else if (operation == &apos;search&apos;) {
		channelName = &apos;rest-api-model-searcher&apos;;
	} else if (operation == &apos;create&apos;) {
		channelName = &apos;rest-api-model-writer&apos;;
	} else if (operation == &apos;update&apos;) {
		channelName = &apos;rest-api-model-updater&apos;;
	}
	var ack = router.routeMessage(channelName, json, false);
	// should return ack but does not always seem to work - so return global variable
	return globalMap.get(&apos;__OE_HTTP_RESULT&apos;);
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>4e7b7377-8c88-4009-8fde-fa03e6790e46</id>
    <name>log</name>
    <tooltip>Logs a message to the logger channel along with the specified details.</tooltip>
    <code>/**
 * Logs a message to the logger channel along with the specified details.
 * Callers should use the global variable &apos;channelId&apos; as the value passed
 * as the channel identifier. A date element is also added as the
 * current date at time of logging. The level is changed to upper case.
 * 
 * Logs are output in the following format:
 * 
 * &lt;log&gt;
 *   &lt;date&gt;&lt;/date&gt;
 *   &lt;level&gt;&lt;/level&gt;
 *   &lt;channelName&gt;&lt;/channelName&gt;
 *   &lt;message&gt;&lt;/message&gt;
 * &lt;/log&gt;
 * 
 * 
 * channelIdentifier - the ID of the source channel.
 * level - the logging level, as a text string.
 * functionName - the name fo the function, if called from a code template.
 * text - the text of the message.
 * 
 */
function log(channelIdentifier, functionName, level, text) {
	var channelName = Packages.com.mirth.connect.server.controllers.ChannelController.getInstance().getDeployedChannelById(channelIdentifier).getName();
    var messageDate = DateUtil.getCurrentDate(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;);
    var xmlMessage = &quot;&lt;log&gt;&lt;date&gt;&quot; + messageDate + &quot;&lt;/date&gt;&quot;;
	if (functionName != null) {
		xmlMessage += &quot;&lt;function&gt;&quot; + functionName + &quot;&lt;/function&gt;&quot;;
	}
    xmlMessage += &quot;&lt;channelName&gt;&quot; + channelName + &quot;&lt;/channelName&gt;&lt;level&gt;&quot; 
                     + level.toUpperCase() + &quot;&lt;/level&gt;&lt;message&gt;&quot;
                     + text + &quot;&lt;/message&gt;&lt;/log&gt;&quot;;
	router.routeMessage(&quot;logger&quot;, xmlMessage);
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>07465c16-325f-467c-86f7-c29c42b3d3a4</id>
    <name>buildFileUtilMessage</name>
    <tooltip>Build a message used to route to the file utils channel.</tooltip>
    <code>/**
 * Build a message used to route to the file utils channel.
 * 
 * Both &apos;move&apos; and &apos;copy&apos; require that the source directory and file,
 * as well as destination directory and file, to be present.
 * 
 * To use &apos;mkdir&apos;, only the source directory needs to be specified;
 * all parent directories will be created if the parent directories
 * do not exist.
 * 
 * op - one of &apos;move&apos;, &apos;copy&apos; or &apos;mkdir&apos;.
 * srcDir - an existing source directory to copy/move the file from,
 * or the name of a directory (including all parent directories)
 * to be created.
 * srcFilename - the name of the file to copy/move.
 * destDir - a directory to copy/move the file to
 * destFilename - the name of the file to copy/move to.
 * 
 */
function buildFileUtilMessage(op, srcDir, srcFilename, destDir, destFilename) {
	return &quot;&lt;fileOperation&gt;&quot;
		+ &quot;&lt;operation&gt;&quot; + op + &quot;&lt;/operation&gt;&quot;
		+ &quot;&lt;sourceDir&gt;&quot; + srcDir + &quot;&lt;/sourceDir&gt;&quot;
		+ &quot;&lt;destDir&gt;&quot; + destDir + &quot;&lt;/destDir&gt;&quot;
		+ &quot;&lt;fileName&gt;&quot; + srcFilename + &quot;&lt;/fileName&gt;&quot;
		+ &quot;&lt;destFileName&gt;&quot; + destFilename + &quot;&lt;/destFileName&gt;&quot;
		+ &quot;&lt;/fileOperation&gt;&quot;
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>d06b9498-a08a-4d9a-a8d4-00e668780f37</id>
    <name>fileAudit</name>
    <tooltip>Audit file information.</tooltip>
    <code>/**
  * Audit information about a given file/directory to the database.
  * 
  * Audits occur when a file is imported, moved, copied, deleted or
  * changed in any way. The following operation codes are used
  * to track such changes:
  * 
  * &apos;i&apos;: shows the initial import of tracking the file/directory in
  *      to OpenEyes. For such an audit, the destination file and
  *      directory are empty;
  * &apos;m&apos;: move a given file or directory to a new location;
  * &apos;c&apos;: copy the given file or directory to a new location;
  * &apos;t&apos;: transform the file (or directory) that is copied/moved
  *      to record that some file is being copied in to another
  *      file, where the copied file is a subset
  *      or superset of the original file. Ultimately it details that
  *      the data in the transformed file takes some, or all, of some,
  *      or all of the transforming source file. A file may contain
  *      many audits of several files transforming in to one file.
  *      Examples include image scaling, taking portions of text or
  *      image subsets of other files and copying them in to the file
  *      to be transformed;
  * &apos;d&apos;: delete the given file or directory.
  * 
  * In all cases, this call only audits database information - it is up
  * to callers to determine that the audit information is correct with
  * regard to recent file/directory transactions.
  * 
  * For auditing creation or deletion of files, the &apos;dest[Parent|Child] parameters
  * do not need to be set. When auditing copy, move or transform operations, the
  * dest[Parent|Child] parameters MUST be set.
  * 
  * Note that the created_date field (mandatory for all OE tables) is filled
  * in at the time of the audit.
  * 
  * TODO need to update user ID too.
  * 
  * operation - char, one of &apos;i&apos; (import/initialise/create), &apos;c&apos; (copy),
  *    &apos;m&apos; (move), &apos;d&apos; (delete) or &apos;t&apos; (transform);
  * type - char, one of &apos;f&apos; (file) or &apos;d&apos; (directory);
  * srcParent - the parent directory of the file/directory being audited;
  * srcChild - the actual file/directory being audited;
  * destParent - the parent directory where the file/directory is being moved/copied
  *    to; for delete or import/create audits, this will be blank.
  * destChild - the actual file/directory being copied/moved; for delete or
  *     import/create audits, this will be blank;
  * srcSize - the size of the file, in bytes, of the source file/dir being audited.
  * destSize - the size of the file, in bytes, of the destinationfile/dir being audited.
  * 
  */
function fileAudit(operation, type, srcParent, srcChild, destParent, destChild, srcSize, destSize) {
	var dbConn = getDbConnection();
	var now = new java.util.Date();
	if (destSize == undefined || destSize &lt; 0) {
		destSize = null;
	}
	var srcParentId = 0;
	if (srcParent != null) {
		srcParentId = getDirectoryId(srcParent);
	}
	var destParentId = 0;
	if (destParentId != null) {
		destParentId = getDirectoryId(destParent);
	}
	var srcChildId = 0;
	if (srcChild != null &amp;&amp; srcChild.isDirectory()) {
		srcChildId = getDirectoryId(srcChild);
	} else if (srcChild != null) {
		srcChildId = getFileId(srcChild);
	}
	var destChildId = 0;
	if (destChild != null &amp;&amp; destChild.isDirectory()) {
		destChildId = getDirectoryId(destChild);
	} else if (destChild != null) {
		destChildId = getFileId(destChild);
	}
log(channelId, &apos;fileAudit&apos;, &apos;info&apos;, &apos;dest child id=&apos; + destChildId);
	var columns = &quot;&quot;;
	var columnValues = &quot;&quot;;
	if (srcParentId &gt; -1) {
		columns = columns + &quot;, src_parent&quot;;
		columnValues = columnValues + &quot;, &apos;&quot; + srcParentId + &quot;&apos;&quot;
	}
	if (destParentId &gt; -1) {
		columns = columns + &quot;, dest_parent&quot;;
		columnValues = columnValues + &quot;, &apos;&quot; +destParentId + &quot;&apos;&quot;
	}
	if (srcChildId &gt; -1) {
		columns = columns + &quot;, src_child&quot;;
		columnValues = columnValues + &quot;, &apos;&quot; + srcChildId + &quot;&apos;&quot;
	}
	if (destChildId &gt; -1) {
		columns = columns + &quot;, dest_child&quot;;
		columnValues = columnValues + &quot;, &apos;&quot; + destChildId + &quot;&apos;&quot;
	}

	var sql = &quot;INSERT INTO &quot;
		+ globalMap.get(&apos;OE_DB_SERVICE_BUS_FILE_AUDIT&apos;)
		+ &quot; (created_date, src_size, dest_size, operation, type&quot; + columns + &quot;)&quot;
    	+ &quot; VALUES (&apos;&quot; +
// TODO getYear is deprecated, but getFullYear fails - sort out js version/libs
		(now.getYear()+1900) + &quot;-&quot; + (now.getMonth()+1) + &quot;-&quot; + now.getDate() + &quot; &quot; + now.getHours() + &quot;:&quot; + now.getMinutes() + &quot;:&quot; + now.getSeconds() + &quot;&apos;, &quot;
		+ srcSize + &quot;, &quot;
		+ destSize + &quot;, &apos;&quot;
		+ operation + &quot;&apos;,&apos;&quot;
    	+ type + &quot;&apos;&quot; + columnValues + &quot;)&quot;
	try {
		var result = dbConn.executeUpdate(sql);
		try {
    	    log(channelId, &apos;fileAudit&apos;, &quot;info&quot;, sql);
    	    log(channelId, &apos;fileAudit&apos;, &quot;info&quot;, &quot;Audit: operation=&quot; + operation 
				+ &quot;, type=&quot; + type
				+ &quot;, src(parent)=&quot; + srcParent 
				+ &quot;, src(child)=&quot; + srcChild 
				+ &quot;, dest(parent)=&quot; + destParent 
				+ &quot;, dest(child)=&quot; + destChild 
				+ &quot;, srcSize=&quot; + srcSize 
				+ &quot;, destSize=&quot; + destSize);
		} catch (err) {
			log(channelId, &apos;fileAudit&apos;, &apos;error&apos;, &apos;Audit failure; failed to log audit information: &apos; + err);
		}
	} catch (err) {
		log(channelId, &apos;fileAudit&apos;, &apos;error&apos;, &apos;Audit failure; failed to execute audit statement \&apos;&apos; + sql + &apos;\&apos;: &apos; + err);
	} finally {
		dbConn.close();
	}
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>2646bab9-9bac-458a-9c9a-77417fa44c7f</id>
    <name>getDbConnection</name>
    <tooltip>Utility to get main database connection.</tooltip>
    <code>/**
 * Gets the DB connection for the OE database.
 */
function getDbConnection() {
	return DatabaseConnectionFactory.createDatabaseConnection(
			&apos;_OE_DB_DRIVER_&apos;,
			&apos;jdbc:mysql://&apos; + globalMap.get(&apos;OE_DB_HOST&apos;) +&apos;:&apos; + globalMap.get(&apos;OE_DB_PORT&apos;) + &apos;/&apos; + globalMap.get(&apos;OE_DB_NAME&apos;),
			globalMap.get(&apos;OE_DB_USER&apos;), globalMap.get(&apos;OE_DB_PASSWORD&apos;));
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>f88d9b6e-90af-4486-bf05-6f2dd88b25cc</id>
    <name>fileLocationChange</name>
    <tooltip></tooltip>
    <code>/**
 * Used as a wrapper call for a move or copy operation for the file utils channel.
 * 
 * If the destination file exists, the source file is moved from
 * the source directory to the specified error directory. The
 * name of the moved file will be based on the time in milliseconds
 * recorded within this call (plus the original file&apos;s suffix).
 * 
 * The process of moving/copying files is audited.
 * 
 * operation - one of &apos;move&apos; or &apos;copy&apos;;
 * src - the source file including full path;
 * dest - the destination file to copy or move (not a directory),
 * including full path to the file;
 * errDest - the error directory (must exist) that the
 * destination file will be moved to if the destination file
 * already exists.
 * 
 * If the copy/move to file already exists, the file is moved to
 * the error directory, named as the current system time (in
 * milliseconds) followed by a period and the file name that
 * produced the error.
 */
function fileLocationChange(operation, src, dest, errDest) {
	var destFile = new java.io.File(dest);
	var destDir = destFile.getParentFile();
	var src = new java.io.File(src);
	var srcDir = src.getParentFile();
	var errDestDir = new java.io.File(errDest);
	if (!destFile.exists()) {
		// Move the image from the in directory to the encoded directory:		
		router.routeMessage(&quot;file-utils&quot;, buildFileUtilMessage(
			operation, srcDir.getAbsolutePath(), src.getName(), destDir.getAbsolutePath(), destFile.getName()),
			false);
	} else {
		// if we can, move the file to the error directory:
		timeFilename = new java.util.Date().getTime()  + &quot;.&quot; + src.getName();
		
		router.routeMessage(&quot;file-utils&quot;, buildFileUtilMessage(
			operation, srcDir.getAbsolutePath(), src.getName(), errDestDir.getAbsolutePath(), timeFilename),
			false);
		log(channelId, &apos;fileLocationChange&apos;, &apos;error&apos;, &apos;Destination file exists; moving &apos; + src + &apos; to &apos; + errDest + &quot;/&quot; + timeFilename);
		return;
	}
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>2e0ba014-c7ef-47a6-ae87-3ecd9098a419</id>
    <name>scaleImage</name>
    <tooltip></tooltip>
    <code>/**
 * Scales the specified source image to the given destination image,
 * width and height. The process of file modification/creation is audited.
 * 
 * key - the file&apos;s key
 * srcImage - the source image to scale; must exist and be a valid image format;
 * destImage - the (non-existant) file to scale the image to;
 * width - the width, in pixels, of the scaled image;
 * height - the height, in pixels, of the scaled image
 * 
 */
function scaleImage(key, srcImage, destImage, width, height) {
	var imageutils = null;
	try {
		imageutils = new Packages._OE_JAVA_PACKAGE_.imageutils.ImageUtils();
	} catch(err) {
		log(channelId, &apos;scaleImage&apos;, &quot;error&quot;, &quot;Failed to load java library: org.statefive.imageutils.ImageUtils&quot;);
		return;
	}

	var srcImageFile = new java.io.File(srcImage);
	var srcImageDir = srcImageFile.getParentFile();
	var destImageFile = new java.io.File(destImage);
	var destImageDir = destImageFile.getParentFile();
	try {
		imageutils.scale(srcImage, width, height, destImage);
		addFileWithKey(destImage, key);
		try {
			fileAudit(&apos;t&apos;, &apos;f&apos;, srcImageDir, srcImageFile, destImageDir, destImageFile, srcImageFile.length(), destImageFile.length());
		}
		catch(err) {
			log(channelId, &apos;scaleImage&apos;, &quot;error&quot;, err);
		}
	} catch(err) {
		log(channelId, &apos;scaleImage&apos;, &quot;error&quot;, &quot;Library invocation failure scaling image: &quot; + err
			+ &quot;; src=&quot; + srcImage + &quot;, dest=&quot; + destImage + &quot;, width=&quot; + width + &quot;, height=&quot; + height);
	}
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>7abc3bd3-53c2-4392-ab16-272356d8e7ac</id>
    <name>getPatientUniquePrefix</name>
    <tooltip></tooltip>
    <code>/**
 * Gets the patient DB ID associated with the specified hospital number.
 * If it does not exist, it is inserted and then returned.
 * 
 * hosNum - the hospital number to query the DB with.
 * 
 * return - the patient&apos;s ID, if there is one; null otherwise.
 */
function getPatientUniquePrefix(hosNum) {
	var prefix = &apos;undefined&apos;;
	var ack = routeModel(&apos;search&apos;, buildRoutableModel(null, &apos;ScannedDocumentUid&apos;, [&apos;pid&apos;], [hosNum]));

	if (ack.getMessage() != null &amp;&amp; ack.getStatus() == &apos;SUCCESS&apos;) {
		var returnState = ack.getMessage().toString();
		if (returnState.substr(0,1) == &apos;[&apos;) {
			var x = JSON.parse(ack.getMessage());
			prefix = x[0].id;
		}
	} else {
		var ack = routeModel(&apos;create&apos;, buildRoutableModel(null, &apos;ScannedDocumentUid&apos;, [&apos;pid&apos;], [hosNum]));
		
		if (ack.getMessage() != null) {
			var returnState = ack.getMessage().toString();
			if (returnState.substr(0,1) == &apos;{&apos;) {
				var x = JSON.parse(ack.getMessage());
				prefix = x.id;
			} 
		}
	}
	return prefix;
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>b3d87f98-3ffd-444c-88fe-f569ce959f7e</id>
    <name>addFile</name>
    <tooltip></tooltip>
    <code>/**
 * Adds a new file. This adds to the main ESB file type that all other file
 * types should create a foreign key to in order to save space for each table.
 * 
 * f - an instance of a java.io.File. It is up to the caller to ensure the
 * file exists and that it is not null.
 * 
 * Return - the id of the file insertion if it was successful; -1 otherwise.
 * 
 */
function addFile(f) {
		
	addFileWithKey(f, null);
	return getFileId(f);
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>95b81f24-eba4-4426-a0de-bcded305a736</id>
    <name>addDirectory</name>
    <tooltip></tooltip>
    <code>/**
 * Adds the specified directory if it does not already exist
 * as an entry in the database.
 * 
 * dir - an instance of a java.io.File. It is up to the caller to ensure the
 * directory exists and that it is not null.
 * 
 * Return the id of the directory; -1 otherwise.
 */
function addDirectory(dir) {
	var path = dir.getAbsolutePath();

	var ack = routeModel(&apos;search&apos;, buildRoutableModel(null, &apos;FsDirectory&apos;, [&apos;path&apos;], [path]));
	if (ack.getMessage() != null &amp;&amp; ack.getStatus() != &apos;SUCCESS&apos;) {
		// TODO Once again, what to do if server down? Need to ensure caller deals with -1 appropriately	
		var ack = routeModel(&apos;create&apos;, buildRoutableModel(null, &apos;FsDirectory&apos;, [&apos;path&apos;, &apos;modified&apos;], [path, dir.lastModified()]));
	}
// if rest call failed, -1 returned - see TODO, above
	return getDirectoryId(dir);
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>f45ba3b4-a8d7-4c22-9384-5da71d5930de</id>
    <name>getFileId</name>
    <tooltip></tooltip>
    <code>/**
 * Gets the file id for the specified file in the database,
 * if it exists.
 * 
 * f - an instance of a java.io.File. It is up to the caller to ensure the
 * file exists and that it is not null.
 * 
 * return the id, or -1 if it doesn&apos;t exist.
 */ 
function getFileId(f) {
	var fileId = -1;
	var dir = f.getParentFile();
	var dir_id = getDirectoryId(dir);

	var fileCache = globalMap.get(&apos;ID_FILE_CACHE&apos;);
	var fileCacheList = globalMap.get(&apos;ID_FILE_CACHE_LIST&apos;);
	if( fileCache[f.getAbsolutePath()] !== undefined ) {
		fileId = fileCache[f.getAbsolutePath()];
	}
	if (fileId &lt; 0) {
		// it&apos;s not cached so look for it:
		var ack = routeModel(&apos;search&apos;, buildRoutableModel(null, &apos;FsFile&apos;, &apos;name modified length dir_id&apos;.split(&apos; &apos;),
			[f.getName(), f.lastModified(), f.length(), dir_id]));

    	    log(channelId, &apos;getfileid&apos;, &quot;info&quot;, &apos;searching for: &apos; + f.getAbsolutePath() + &apos;, &apos; + f.getName() + &apos;, &apos; + f.lastModified() + &apos;, &apos; + f.length() + &apos;, &apos; + dir_id);
			log(channelId, &apos;getfileid&apos;, &quot;info&quot;, &apos;message results: &apos; + ack.getStatus() + &apos;, &apos; +  + ack.getMessage());
		if (ack.getMessage() != null &amp;&amp; ack.getStatus() == &apos;SUCCESS&apos;) {
			var returnState = ack.getMessage().toString();
			if (returnState.substr(0,1) == &apos;[&apos;) {
				var x = JSON.parse(ack.getMessage());
				if (x.length &gt; 0) {
					fileId = x[0].id;
					fileCache[f.getAbsolutePath()] = fileId;
					fileCacheList.push(f.getAbsolutePath());
					fileCacheList.push(fileCache[f.getAbsolutePath()]);
					if (fileCacheList.length &gt; 20) {
						delete fileCache[fileCacheList.shift()];
					}
				}
			} 
		}
	}
	return fileId;
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>1ff0a986-9879-4054-a5ca-885c1a68b5eb</id>
    <name>getDirectoryId</name>
    <tooltip></tooltip>
    <code>/**
 * Gets the directory id for the specified directory, if it exists
 * in the database.
 * 
 * dir - an instance of a java.io.File. It is up to the caller to ensure the
 * directory exists and that it is not null.
 * 
 * The id, if the entry for the directory exists; -1 otherwise.
 */ 
function getDirectoryId(dir) {
	var dbConn = getDbConnection();
	var dirId = -1;
	if (dir != null) {
		var path = dir.getAbsolutePath();

		var dirCache = globalMap.get(&apos;ID_DIR_CACHE&apos;);
		var dirCacheList = globalMap.get(&apos;ID_DIR_CACHE_LIST&apos;);

		if( dirCache[path] !== undefined ) {
			dirId = dirCache[path];
		}

		if (dirId &lt; 0) {
			// it&apos;s not cached so look for it:
			var ack = routeModel(&apos;search&apos;, buildRoutableModel(null, &apos;FsDirectory&apos;, [&apos;path&apos;, &apos;modified&apos;], [path, dir.lastModified()]));

			if (ack.getMessage() != null &amp;&amp; ack.getStatus() == &apos;SUCCESS&apos;) {
				var returnState = ack.getMessage().toString();
				if (returnState.substr(0,1) == &apos;[&apos;) {
					var x = JSON.parse(ack.getMessage());
					if (x.length &gt; 0) {
						dirId = x[0].id;
						dirCache[path] = dirId;
						dirCacheList.push(path);
						dirCacheList.push(dirCache[path]);
						if (dirCacheList.length &gt; 20) {
							delete dirCache[dirCacheList.shift()];
						}
					}
				} 
			}
		}
	}
	return dirId;
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>7cb03aa4-af8f-40c2-8162-634c7f5281f7</id>
    <name>getFileKey</name>
    <tooltip></tooltip>
    <code>/**
 * Gets the unique key for the specified file identifier,
 * if it exists.
 * 
 * fileId - the unique file ID.
 * 
 * Return - the file&apos;s key, if it could be found; -1 otherwise.
 */
function getFileKey(fileId) {
	var fileKey = -1;

	var ack = routeModel(&apos;view&apos;, buildRoutableModel(fileId, &apos;FsFile&apos;));

	if (ack.getMessage() != null) {
		var returnState = ack.getMessage().toString();
		if (returnState.substr(0,1) == &apos;{&apos;) {
			var x = JSON.parse(ack.getMessage());
			fileKey = x.id;
		} 
	}
	return fileKey;
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>41c93948-6c48-45da-8c63-2883b2ef8292</id>
    <name>addFileWithKey</name>
    <tooltip></tooltip>
    <code>/**
 * Adds a new file with the specified key. Note that normally, the key is
 * based on the time the file was imported - for files arriving on the ESB.
 * However, all &apos;related&apos; files, that is, all files that are copied or moved,
 * must retain the key from the file that was moved from or copied from.
 * This function allows a caller to add the specified ID to the DB
 * with the original file&apos;s key (use getFileKey(id) to get another file&apos;s
 * key).
 * 
 * f - an instance of a java.io.File. It is up to the caller to ensure the
 * file exists and that it is not null.
 * 
 * key - the key to add with the specified file.
 * 
 * Return - the id of the file insertion if it was successful; -1 otherwise.
 * 
 */
function addFileWithKey(f, key) {

	var dir = f.getParentFile();
	var dir_id = addDirectory(dir);
	var createdDate = DateUtil.getCurrentDate(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	if (getFileId(f) &lt; 0) {
		var dbConn = getDbConnection();
		var tstamp = f.lastModified();
		var length = f.length();
		var name = f.getName();

		var ack = routeModel(&apos;create&apos;, buildRoutableModel(null, &apos;FsFile&apos;, &apos;name modified created_date length chronological_key dir_id&apos;.split(&apos; &apos;),
						[f.getName(), f.lastModified(), createdDate, f.length(), key, dir_id]))

		if (ack.getMessage() != null &amp;&amp; ack.getStatus() == &apos;SUCCESS&apos;) {
			// TODO ... what to do?
		} else {
			// leave the file here? It could be that the server is down...
			// TODO need to give this some thought
			log(channelId, &apos;info&apos;, &apos;Failed - ACK message is NULL&apos;);
		}
	}
	return getFileId(f);
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>a9d852b5-dda1-4585-96ef-fea55e925900</id>
    <name>createAsset</name>
    <tooltip></tooltip>
    <code>/**
 * Gets the file id for the specified file in the database,
 * if it exists.
 * 
 * f - an instance of a java.io.File. It is up to the caller to ensure the
 * file exists and that it is not null.
 * 
 * return the id, or -1 if it doesn&apos;t exist.
 */ 
function createAsset(name, title, description, mimetype, filesize, extension) {
	var dbConn = getDbConnection();
	var sql = null;
	var assetId = -1;
	var createdDate = DateUtil.getCurrentDate(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	var ack = routeModel(&apos;create&apos;, buildRoutableModel(null, &apos;Asset&apos;, &apos;name title description mimetype filesize extension created_date&apos;.split(&apos; &apos;),
		[name, title, description, mimetype, filesize, extension, createdDate]));
	assetId = JSON.parse(ack.getMessage()).id;
	return assetId;
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>01911bd4-3cff-4fa6-a062-96bd415fab77</id>
    <name>getCurrentDateTime</name>
    <tooltip></tooltip>
    <code>// modify function_name and parameters as you wish.
// one function per template is recommended. i.e.) create a new code template for each new function.
function getCurrentDateTime() {
	var currentTime = java.lang.System.currentTimeMillis();
	var date = new java.io.Date(currentTime);
	var dateFormatter = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
	
	return dateFormatter.format(date);
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>f3b3c244-8d3e-4bfe-a1bf-cd372935185f</id>
    <name>linkAssetWithFile</name>
    <tooltip></tooltip>
    <code>/**
 * 
 * 
 * 
 * 
 * 
 */
function linkAssetWithFile(assetId, fileId) {
	routeModel(&apos;update&apos;, buildRoutableModel(assetId, &apos;Asset&apos;, [&apos;file_id&apos;], [fileId]));
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>7021cf20-49d6-4eb1-8fe1-d10689ddbbe6</id>
    <name>buildRoutableModel</name>
    <tooltip></tooltip>
    <code>/**
 * Creates necessary message data for sending to the model reader/writer/updater.
 * Essentiall it is XML with root element &apos;model&apos;, child elements
 * &apos;name&apos; for the class name of the model and &apos;json&apos; for
 * the JSON used to create/update the object. The JSON should
 * represent the attributes and their values to update.
 * 
 * @param id used for view/update only; null otherwise, gives
 * the id to view/upddate.
 * @param string the class name of the model to create.
 * @param array column names for the properties to set.
 * @param array column values, paired 1-1 with the column names.
 * 
 * @return a message containing the necessary XML/JSON for the
 * model reader/writer/updater to recieve.
 * 
 */
function buildRoutableModel(id, model, columns, values) {
	var data = &apos;&lt;model&gt;&lt;name&gt;&apos; + model + &apos;&lt;/name&gt;&apos;;
	if (id != null) {
		data = data + &apos;&lt;id&gt;&apos; + id + &apos;&lt;/id&gt;&apos;;
	}
	if (columns != null) {
		data = data + &apos;&lt;json&gt;{ &apos;;
		for (i = 0; i &lt; columns.length - 1; i++) {
			data = data + &apos;&quot;&apos; + columns[i] + &apos;&quot;: &quot;&apos; + values[i] + &apos;&quot;, &apos;;
		}
		data = data + &apos;&quot;&apos; + columns[values.length-1] + &apos;&quot;: &quot;&apos; + values[values.length-1] + &apos;&quot; }&lt;/json&gt;&apos;;
	}
	return data + &apos;&lt;/model&gt;&apos;;
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
  <codeTemplate>
    <id>6ed19e4f-0164-4e6c-8690-2d8b777f9f14</id>
    <name>createHumphreyImagePairEvent</name>
    <tooltip></tooltip>
    <code>// modify function_name and parameters as you wish.
// one function per template is recommended. i.e.) create a new code template for each new function.
function createHumphreyImagePairEvent(patient_id, tif_image_id, xml_id, test_strategy) {
	var messageData = &quot;&lt;createHumphreyImagePairEvent&gt;&quot;
	+ &quot;&lt;patient_id&gt;&quot; + patient_id + &quot;&lt;/patient_id&gt;&quot;
	+ &quot;&lt;tif_file_id&gt;&quot; + tif_image_id + &quot;&lt;/tif_file_id&gt;&quot;
	+ &quot;&lt;xml_id&gt;&quot; + xml_id + &quot;&lt;/xml_id&gt;&quot;
	+ &quot;&lt;test_strategy&gt;&quot; + test_strategy + &quot;&lt;/test_strategy&gt;&quot;
	+ &quot;&lt;/createHumphreyImagePairEvent&gt;&quot;;

	var ack = router.routeMessage(&apos;rest-api&apos;, messageData, false);
}</code>
    <type>FUNCTION</type>
    <scope>0</scope>
    <version>2.2.1.5861</version>
  </codeTemplate>
</list>